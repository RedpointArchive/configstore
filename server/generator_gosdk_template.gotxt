const traceDefaultServiceName = "configstore client"

// ==== tracing code begin ====
// ==== tracing.go and generator_gosdk_template.gotxt should be identical here ====

var hasInited bool
var traceServiceName string
var traceEnabled bool

func doInit() {
	traceServiceName = os.Getenv("CONFIGSTORE_SERVICE_NAME")
	if traceServiceName == "" {
		traceServiceName = traceDefaultServiceName
	}
	traceEnabled = os.Getenv("CONFIGSTORE_ENABLE_TRACE") == "1"
	hasInited = true
}

func getTraceServiceName() string {
	if !hasInited {
		doInit()
	}
	return traceServiceName
}

func isTracingEnabled() bool {
	if !hasInited {
		doInit()
	}
	return traceEnabled
}

func serializeMetaEntityForTrace(entity *MetaEntity) string {
	var lines []string
	lines = append(lines, "")
	lines = append(lines, fmt.Sprintf("  key = %s", SerializeKey(entity.Key)))
	for _, value := range entity.Values {
		serValue := "(unknown)"
		switch value.Type {
		case ValueType_double:
			serValue = fmt.Sprintf("%f", value.DoubleValue)
		case ValueType_int64:
			serValue = fmt.Sprintf("%d", value.Int64Value)
		case ValueType_string:
			serValue = value.StringValue
		case ValueType_timestamp:
			serValue = fmt.Sprintf("%+v", value.TimestampValue)
		case ValueType_boolean:
			if value.BooleanValue {
				serValue = "true"
			} else {
				serValue = "false"
			}
		case ValueType_bytes:
			serValue = "(bytes)"
		case ValueType_key:
			if value.KeyValue == nil {
				serValue = "(nil)"
			} else {
				serValue = SerializeKey(value.KeyValue)
			}
		case ValueType_uint64:
			serValue = fmt.Sprintf("%d", value.Uint64Value)
		}
		lines = append(lines, fmt.Sprintf("  %d = %s", value.Id, serValue))
	}
	return strings.Join(lines, "\n")
}

func RecordTrace(trace *ConfigstoreTraceEntry) {
	if !isTracingEnabled() {
		return
	}

	RecordTraceWithCustomEntity(trace, nil)
}

func RecordTraceWithCustomEntity(trace *ConfigstoreTraceEntry, entity interface{}) {
	if !isTracingEnabled() {
		return
	}

	var entityString string
	if entity != nil {
		metaEntity, ok := entity.(*MetaEntity)
		if ok {
			entityString = serializeMetaEntityForTrace(metaEntity)
		} else {
			entityString = fmt.Sprintf("%+v", entity)
		}
	} else {
		if trace.Entity != nil {
			entityString = serializeMetaEntityForTrace(trace.Entity)
		}
	}

	switch trace.Type {
	case ConfigstoreTraceEntry_INITIAL_STATE_SEND_BEGIN:
		log.Printf("%s: initial state: send begin", trace.OperatorId)
	case ConfigstoreTraceEntry_INITIAL_STATE_SEND_ENTITY:
		log.Printf("%s: initial state: send entity: %s", trace.OperatorId, entityString)
	case ConfigstoreTraceEntry_INITIAL_STATE_SEND_END:
		log.Printf("%s: initial state: send end", trace.OperatorId)
	case ConfigstoreTraceEntry_INITIAL_STATE_RECEIVE_BEGIN:
		log.Printf("%s: initial state: receive begin", trace.OperatorId)
	case ConfigstoreTraceEntry_INITIAL_STATE_RECEIVE_ENTITY:
		log.Printf("%s: initial state: receive entity: %s", trace.OperatorId, entityString)
	case ConfigstoreTraceEntry_INITIAL_STATE_RECEIVE_END:
		log.Printf("%s: initial state: receive end", trace.OperatorId)
	case ConfigstoreTraceEntry_TRANSACTION_BATCH_SEND_BEGIN:
		log.Printf("%s: transaction batch: %s: send begin", trace.OperatorId, trace.TransactionId)
	case ConfigstoreTraceEntry_TRANSACTION_BATCH_SEND_MUTATED_ENTITY:
		log.Printf("%s: transaction batch: %s: send mutated entity: %s", trace.OperatorId, trace.TransactionId, entityString)
	case ConfigstoreTraceEntry_TRANSACTION_BATCH_SEND_DELETED_ENTITY_KEY:
		log.Printf("%s: transaction batch: %s: send deleted entity key: %s", trace.OperatorId, trace.TransactionId, SerializeKey(trace.Key))
	case ConfigstoreTraceEntry_TRANSACTION_BATCH_SEND_END:
		log.Printf("%s: transaction batch: %s: send end", trace.OperatorId, trace.TransactionId)
	case ConfigstoreTraceEntry_TRANSACTION_BATCH_RECEIVE_BEGIN:
		log.Printf("%s: transaction batch: %s: receive begin", trace.OperatorId, trace.TransactionId)
	case ConfigstoreTraceEntry_TRANSACTION_BATCH_RECEIVE_MUTATED_ENTITY:
		log.Printf("%s: transaction batch: %s: receive mutated entity: %s", trace.OperatorId, trace.TransactionId, entityString)
	case ConfigstoreTraceEntry_TRANSACTION_BATCH_RECEIVE_DELETED_ENTITY_KEY:
		log.Printf("%s: transaction batch: %s: receive deleted entity key: %s", trace.OperatorId, trace.TransactionId, SerializeKey(trace.Key))
	case ConfigstoreTraceEntry_TRANSACTION_BATCH_RECEIVE_END:
		log.Printf("%s: transaction batch: %s: receive end", trace.OperatorId, trace.TransactionId)
	case ConfigstoreTraceEntry_IN_MEMORY_STORE_ENTITY:
		log.Printf("%s: in memory: store %s", trace.OperatorId, entityString)
	case ConfigstoreTraceEntry_IN_MEMORY_DELETE_ENTITY:
		log.Printf("%s: in memory: delete %s", trace.OperatorId, SerializeKey(trace.Key))
	case ConfigstoreTraceEntry_TRANSACTION_ARRIVED:
		log.Printf("%s: transaction queue: %s: transaction arrived", trace.OperatorId, trace.TransactionId)
	case ConfigstoreTraceEntry_TRANSACTION_FINISHED_PROCESSING:
		log.Printf("%s: transaction queue: %s: finished processing transaction (%d transactions left to process)", trace.OperatorId, trace.TransactionId, trace.RemainingTransactionQueueCount)
	case ConfigstoreTraceEntry_TRANSACTION_STALLED:
		log.Printf("%s: transaction queue: %s: can't process transaction, waiting on entity snapshot with key: %s", trace.OperatorId, trace.TransactionId, SerializeKey(trace.Key))
	case ConfigstoreTraceEntry_CONFIGSTORE_CONSISTENT:
		log.Printf("%s: consistent and ready to serve transactions", trace.OperatorId)
	case ConfigstoreTraceEntry_TRANSACTION_MUTATED_ENTITY_KEY:
		log.Printf("%s: transaction queue: %s: transaction contained mutated entity key: %s", trace.OperatorId, trace.TransactionId, SerializeKey(trace.Key))
	case ConfigstoreTraceEntry_TRANSACTION_DELETED_ENTITY_KEY:
		log.Printf("%s: transaction queue: %s: transaction contained deleted entity key: %s", trace.OperatorId, trace.TransactionId, SerializeKey(trace.Key))
	case ConfigstoreTraceEntry_TRANSACTION_RECONSTRUCT_APPEND_MUTATED_ENTITY:
		log.Printf("%s: transaction reconstructor: %s: append mutated entity with key %s: %s", trace.OperatorId, trace.TransactionId, SerializeKey(trace.Key), entityString)
	case ConfigstoreTraceEntry_CLIENT_CURRENTLY_DISCONNECTED_ATTEMPTING_RECONNECT:
		log.Printf("%s: currently disconnected, attempting to reconnect...", trace.OperatorId)
	case ConfigstoreTraceEntry_CLIENT_FAILED_RECONNECT:
		log.Printf("%s: failed to reconnect: %s", trace.OperatorId, trace.ErrorString)
	case ConfigstoreTraceEntry_CLIENT_CONNECTION_REESTABLISHED:
		log.Printf("%s: connection re-established", trace.OperatorId)
	case ConfigstoreTraceEntry_CLIENT_GOT_EOF_ATTEMPTING_RECONNECTING:
		log.Printf("%s: got EOF from configstore endpoint, attempting to reconnect...", trace.OperatorId)
	case ConfigstoreTraceEntry_CLIENT_GOT_NIL_BUG_IGNORING:
		log.Printf("%s: got nil response from endpoint (this is a bug), ignoring...", trace.OperatorId)
	case ConfigstoreTraceEntry_CLIENT_GOT_UNEXPECTED_CODE_ATTEMPTING_RECONNECT:
		log.Printf("%s: got %s code from configstore endpoint, attempting to reconnect...", trace.OperatorId, trace.ReconnectionCodeString)
	case ConfigstoreTraceEntry_SERVER_STARTUP_GRPC_PORT:
		log.Printf("%s: running gRPC server on port %d...", trace.OperatorId, trace.Port)
	case ConfigstoreTraceEntry_SERVER_STARTUP_HTTP_PORT:
		log.Printf("%s: running HTTP server on port %d...", trace.OperatorId, trace.Port)
	}
}

// ==== tracing code end ====

func Fnv64a(val string) uint64 {
	hash := fnv.New64a()
	hash.Write(([]byte)(val))
	return hash.Sum64()
}

func Fnv64aPair(a uint64, b uint64) uint64 {
	hash := fnv.New64a()
	if a > b {
		tmp := a
		a = b
		b = tmp
	}
	key := make([]byte, 16)
	binary.LittleEndian.PutUint64(key, a)
	binary.LittleEndian.PutUint64(key[8:], b)
	hash.Write(key)
	return hash.Sum64()
}

func GetInputForFnv64aFromKey(k *Key) string {
	if k == nil || len(k.Path) == 0 {
		return ""
	}
	return k.Path[len(k.Path)-1].GetName()
}

func CreateTopLevelKey(partitionId *PartitionId, pathElement *PathElement) *Key {
	return &Key{
		PartitionId: partitionId,
		Path: []*PathElement{pathElement},
	}
}

func CreateIncompleteTopLevelKey(partitionId *PartitionId, kind string) *Key {
	return &Key{
		PartitionId: partitionId,
		Path: []*PathElement{
			&PathElement{
				Kind: kind,
			},
		},
	}
}

func CreateDescendantKey(parent *Key, pathElement *PathElement) *Key {
	newKey := &Key{
		PartitionId: &PartitionId{
			Namespace: parent.PartitionId.Namespace,
		},
		Path: nil,
	}
	for _, elem := range parent.Path {
		switch elem.IdType.(type) {
		case *PathElement_Id:
			newKey.Path = append(newKey.Path, &PathElement{
				Kind: elem.Kind,
				IdType: &PathElement_Id{
					Id: elem.GetId(),
				},
			})
			break
		case *PathElement_Name:
			newKey.Path = append(newKey.Path, &PathElement{
				Kind: elem.Kind,
				IdType: &PathElement_Name{
					Name: elem.GetName(),
				},
			})
			break
		}
	}
	switch pathElement.IdType.(type) {
	case *PathElement_Id:
		newKey.Path = append(newKey.Path, &PathElement{
			Kind: pathElement.Kind,
			IdType: &PathElement_Id{
				Id: pathElement.GetId(),
			},
		})
		break
	case *PathElement_Name:
		newKey.Path = append(newKey.Path, &PathElement{
			Kind: pathElement.Kind,
			IdType: &PathElement_Name{
				Name: pathElement.GetName(),
			},
		})
		break
	}
	return newKey
}

func SerializeTimestamp(ts *timestamp.Timestamp) string {
	if ts == nil {
		return ""
	}

	return ts.String()
}

func SerializeKey(key *Key) string {
	if key == nil {
		return ""
	}

	var elements []string
	for _, pathElement := range key.Path {
		if _, ok := pathElement.IdType.(*PathElement_Id); ok {
			elements = append(elements, fmt.Sprintf("%s:id=%d", pathElement.GetKind(), pathElement.GetId()))
		} else if _, ok := pathElement.IdType.(*PathElement_Name); ok {
			elements = append(elements, fmt.Sprintf("%s:name=%s", pathElement.GetKind(), pathElement.GetName()))
		} else {
			elements = append(elements, fmt.Sprintf("%s:unset", pathElement.GetKind()))
		}
	}
	return fmt.Sprintf("ns=%s|%s", key.PartitionId.Namespace, strings.Join(elements, "|"))
}

func CompareKeys(a *Key, b *Key) bool {
	return SerializeKey(a) == SerializeKey(b)
}

{{ range $kindName, $kind := .Kinds }}
func CreateTopLevel_{{ $kindName }}_NameKey(partitionId *PartitionId, name string) *Key {
	return &Key{
		PartitionId: partitionId,
		Path: []*PathElement{
			&PathElement{
				Kind: "{{ $kindName }}",
				IdType: &PathElement_Name{
					Name: name,
				},
			},
		},
	}
}

func CreateTopLevel_{{ $kindName }}_IdKey(partitionId *PartitionId, id int64) *Key {
	return &Key{
		PartitionId: partitionId,
		Path: []*PathElement{
			&PathElement{
				Kind: "{{ $kindName }}",
				IdType: &PathElement_Id{
				  Id: id,
				},
			},
		},
	}
}

func CreateTopLevel_{{ $kindName }}_IncompleteKey(partitionId *PartitionId) *Key {
	return &Key{
		PartitionId: partitionId,
		Path: []*PathElement{
			&PathElement{
				Kind: "{{ $kindName }}",
				IdType: nil,
			},
		},
	}
}

func (src *{{ $kindName }}) Copy() *{{ $kindName }} {
	// NOTE: This doesn't deep copy keys or timestamps, because we don't
	// expect those to be mutated in-place...
	dest := *src
	return &dest
}
{{ end }}

{{- define "fieldindexkeytype" -}}
{{- if eq .Type 1 -}}
float64
{{- else if eq .Type 2 -}}
int64
{{- else if eq .Type 8 -}}
uint64
{{- else if eq .Type 4 -}}
string
{{- else if eq .Type 6 -}}
string
{{- else if eq .Type 7 -}}
string
{{- else if eq .Type 5 -}}
bool
{{- else if eq .Type 3 -}}
string
{{- end -}}
{{- end -}}

{{- define "fieldindexorigtype" -}}
{{- if eq .Type 1 -}}
float64
{{- else if eq .Type 2 -}}
int64
{{- else if eq .Type 8 -}}
uint64
{{- else if eq .Type 4 -}}
*timestamp.Timestamp
{{- else if eq .Type 6 -}}
[]byte
{{- else if eq .Type 7 -}}
*Key
{{- else if eq .Type 5 -}}
bool
{{- else if eq .Type 3 -}}
string
{{- end -}}
{{- end -}}

{{- define "fieldindexserializetotype" -}}
{{- if eq .Type 4 -}}
SerializeTimestamp(key)
{{- else if eq .Type 6 -}}
string(key)
{{- else if eq .Type 7 -}}
SerializeKey(key)
{{- else -}}
key
{{- end -}}
{{- end -}}

{{ define "indexstoresupdate" }}
	newEntity := resp.Entity
	_ = newEntity
	{{ template "indexstoresupdateinternal" . }}
{{ end }}

{{ define "getfnv64avalueforfield" -}}
{{- if eq .Type 3 -}}
e.{{- camelcase .Name -}}
{{- else if eq .Type 7 -}}
GetInputForFnv64aFromKey(e.{{- camelcase .Name -}})
{{- else -}}
(ERROR, incorrect type for fnv64a computed field)
{{- end -}}
{{- end }}

{{ define "getfnv64apairvalueforfield" -}}
{{- if eq .Type 2 -}}
e.{{- camelcase .Name -}}
{{- else if eq .Type 3 -}}
Fnv64a({{- template "getfnv64avalueforfield" . -}})
{{- else if eq .Type 7 -}}
Fnv64a({{- template "getfnv64avalueforfield" . -}})
{{- else -}}
(ERROR, incorrect type for fnv64a pair computed field)
{{- end -}}
{{- end }}

{{ define "indexstoresupdateinternal" }}
	{{ $kind := getschemakind . -}}
	{{- $kindName := . }}
	{{- range $i, $index := $kind.Indexes -}}
		{{- if isinmemoryindex $index -}}
			{{- if isfieldindex $index -}}
				{{- $field := getfieldforindex $kindName $index -}}
				{{- if $field -}}
{
	key := newEntity.{{- camelcase $field.Name }}
	idx := {{- template "fieldindexserializetotype" $field }}
	ref.indexstore_{{- $index.Name -}}[idx] = newEntity
}
				{{ end -}}
			{{- else if iscomputedindex $index -}}
				{{- if iscomputedfnv64aindex $index -}}
					{{- $field := getcomputedfnv64afieldforindex $kindName $index -}}
					{{- if $field }}
{
	e := newEntity
	key := {{ template "getfnv64avalueforfield" $field }}
	idx := Fnv64a(key)
	ref.indexstore_{{- $index.Name -}}[idx] = newEntity
}
					{{ end -}}
				{{- else if iscomputedfnv64apairindex $index -}}
					{{- $field1 := getcomputedfnv64apairfield1forindex $kindName $index -}}
					{{- $field2 := getcomputedfnv64apairfield2forindex $kindName $index -}}
					{{- if and $field1 $field2 }}
{
	e := newEntity
	field1 := {{ template "getfnv64apairvalueforfield" $field1 }}
	field2 := {{ template "getfnv64apairvalueforfield" $field2 }}
	idx := Fnv64aPair(field1, field2)
	ref.indexstore_{{- $index.Name -}}[idx] = newEntity
}
					{{ end -}}
				{{- end -}}
			{{- end -}}
		{{- end -}}
	{{- end -}}
{{ end }}

{{ define "indexstoresremove" }}
	oldEntity, ok := ref.store[s]
	if ok {
		_ = oldEntity
		{{ template "indexstoresremoveinternal" . }}
	}
{{ end }}

{{ define "indexstoresremoveinternal" }}
	{{ $kind := getschemakind . -}}
	{{- $kindName := . }}
	{{- range $i, $index := $kind.Indexes -}}
		{{- if isinmemoryindex $index -}}
			{{- if isfieldindex $index -}}
				{{- $field := getfieldforindex $kindName $index -}}
				{{- if $field -}}
{
	key := oldEntity.{{- camelcase $field.Name }}
	idx := {{- template "fieldindexserializetotype" $field }}
	delete(ref.indexstore_{{- $index.Name -}}, idx)
}
				{{ end -}}
			{{- else if iscomputedindex $index -}}
				{{- if iscomputedfnv64aindex $index -}}
					{{- $field := getcomputedfnv64afieldforindex $kindName $index -}}
					{{- if $field }}
{
	e := oldEntity
	key := {{ template "getfnv64avalueforfield" $field }}
	idx := Fnv64a(key)
	delete(ref.indexstore_{{- $index.Name -}}, idx)
}
					{{ end -}}
				{{- else if iscomputedfnv64apairindex $index -}}
					{{- $field1 := getcomputedfnv64apairfield1forindex $kindName $index -}}
					{{- $field2 := getcomputedfnv64apairfield2forindex $kindName $index -}}
					{{- if and $field1 $field2 }}
{
	e := oldEntity
	field1 := {{ template "getfnv64apairvalueforfield" $field1 }}
	field2 := {{ template "getfnv64apairvalueforfield" $field2 }}
	idx := Fnv64aPair(field1, field2)
	delete(ref.indexstore_{{- $index.Name -}}, idx)
}
					{{ end -}}
				{{- end -}}
			{{- end -}}
		{{- end -}}
	{{- end }}
{{ end }}

type Configstore struct {
	conn *grpc.ClientConn
	mutex sync.RWMutex

	{{ range $kindName, $kind := .Kinds }}
	{{ $kindName }}s {{ $kindName }}Store
	{{ end }}
}

{{ range $kindName, $kind := .Kinds }}
type {{ $kindName }}Snapshot struct {
	{{ $kindName }}s map[string]*{{ $kindName }}
	{{ range $i, $index := $kind.Indexes -}}
		{{- if isinmemoryindex $index -}}
			{{- if isfieldindex $index -}}
				{{- $field := getfieldforindex $kindName $index -}}
				{{- if $field }}
	{{ $kindName }}s_By{{ $index.Name }} map[{{ template "fieldindexkeytype" $field }}]*{{ $kindName }}
				{{ end -}}
			{{- else if iscomputedindex $index -}}
				{{- if iscomputedfnv64aindex $index }}
	{{ $kindName }}s_By{{ $index.Name }} map[uint64]*{{ $kindName }}
				{{ else if iscomputedfnv64apairindex $index }}
	{{ $kindName }}s_By{{ $index.Name }} map[uint64]*{{ $kindName }}
				{{ end -}}
			{{- end -}}
		{{- end -}}
	{{- end -}}
}
{{ end }}

func (configstore *Configstore) TakeSnapshots(snapshots ...interface{}) {
	configstore.mutex.RLock()
	for _, snapshot := range snapshots {
		switch s := snapshot.(type) {
{{ range $kindName, $kind := .Kinds }}
		case *{{ $kindName }}Snapshot:
			src := configstore.{{ $kindName }}s.(*{{ $kindName }}ImplStore)
			s.{{ $kindName }}s = make(map[string]*{{ $kindName }})
			for k, v := range src.store {
				s.{{ $kindName }}s[k] = v.Copy()
			}
	{{ range $i, $index := $kind.Indexes -}}
		{{- if isinmemoryindex $index -}}
			{{- if isfieldindex $index -}}
				{{- $field := getfieldforindex $kindName $index -}}
				{{- if $field }}
			s.{{ $kindName }}s_By{{ $index.Name }} = make(map[{{ template "fieldindexkeytype" $field }}]*{{ $kindName }})
			for k, v := range src.indexstore_{{ $index.Name }} {
				s.{{ $kindName }}s_By{{ $index.Name }}[k] = v.Copy()
			}
				{{ end -}}
			{{- else if iscomputedindex $index -}}
				{{- if iscomputedfnv64aindex $index }}
			s.{{ $kindName }}s_By{{ $index.Name }} = make(map[uint64]*{{ $kindName }})
			for k, v := range src.indexstore_{{ $index.Name }} {
				s.{{ $kindName }}s_By{{ $index.Name }}[k] = v.Copy()
			}
				{{ else if iscomputedfnv64apairindex $index }}
			s.{{ $kindName }}s_By{{ $index.Name }} = make(map[uint64]*{{ $kindName }})
			for k, v := range src.indexstore_{{ $index.Name }} {
				s.{{ $kindName }}s_By{{ $index.Name }}[k] = v.Copy()
			}
				{{ end -}}
			{{- end -}}
		{{- end -}}
	{{- end -}}
{{ end }}
		}
	}
	configstore.mutex.RUnlock()
}

func ConnectToConfigstore(ctx context.Context, conn *grpc.ClientConn) (*Configstore, error) {
	configstore := &Configstore{
		conn: conn,
	}
	{{ range $kindName, $kind := .Kinds }}
	configstore.{{ $kindName }}s = &{{ $kindName }}ImplStore{
		configstore: configstore,
		client:   New{{ $kindName }}ServiceClient(configstore.conn),
		store:    make(map[string]*{{ $kindName }}),
		{{ range $i, $index := $kind.Indexes }}
			{{ if isinmemoryindex $index }}
				{{ if isfieldindex $index }}
					{{ $field := getfieldforindex $kindName $index }}
					{{ if $field }}
		indexstore_{{ $index.Name }}: make(map[{{ template "fieldindexkeytype" $field }}]*{{ $kindName }}),
					{{ end }}
				{{ else if iscomputedindex $index }}
					{{ if iscomputedfnv64aindex $index }}
		indexstore_{{ $index.Name }}: make(map[uint64]*{{ $kindName }}),
					{{ else if iscomputedfnv64apairindex $index }}
		indexstore_{{ $index.Name }}: make(map[uint64]*{{ $kindName }}),
					{{ end }}
				{{ end }}
			{{ end }}
		{{ end }}
	}
	{{ end }}
	client := NewTransactionServiceClient(configstore.conn)
	var mut sync.Mutex
	isLocked := true
	mut.Lock()
	watcher, watcherErr := client.Watch(ctx, &TypedWatchTransactionsRequest{})
	if watcherErr != nil {
		return nil, watcherErr
	}
	go func() {
		for {
			if watcher == nil {
				// watcher can become nil if we lose connection, attempt to reconnect (setting watcher = newWatcher),
				// but the connection failed on the reconnection attempt and we don't actually have a valid connection
				// yet. in this case, the connection is already closed, and we just need to attempt to reconnect until
				// we're back.
				RecordTrace(&ConfigstoreTraceEntry{
					OperatorId:                     getTraceServiceName(),
					Type:                           ConfigstoreTraceEntry_CLIENT_CURRENTLY_DISCONNECTED_ATTEMPTING_RECONNECT,
				})
				newWatcher, watcherReconnectErr := client.Watch(ctx, &TypedWatchTransactionsRequest{})
				watcher = newWatcher
				if watcherReconnectErr != nil {
					RecordTrace(&ConfigstoreTraceEntry{
						OperatorId:                     getTraceServiceName(),
						Type:                           ConfigstoreTraceEntry_CLIENT_FAILED_RECONNECT,
						ErrorString: 										fmt.Sprintf("%v", watcherReconnectErr),
					})
					time.Sleep(30 * time.Second)
					continue
				} else {
					// Connection re-established, keep going to receive updates.
					RecordTrace(&ConfigstoreTraceEntry{
						OperatorId:                     getTraceServiceName(),
						Type:                           ConfigstoreTraceEntry_CLIENT_CONNECTION_REESTABLISHED,
					})
				}
			}

			resp, respErr := watcher.Recv()
			if respErr == io.EOF {
				// Retry the Watch request itself
				RecordTrace(&ConfigstoreTraceEntry{
					OperatorId:                     getTraceServiceName(),
					Type:                           ConfigstoreTraceEntry_CLIENT_GOT_EOF_ATTEMPTING_RECONNECTING,
				})
				watcher.CloseSend()
				newWatcher, watcherReconnectErr := client.Watch(ctx, &TypedWatchTransactionsRequest{})
				watcher = newWatcher
				if watcherReconnectErr != nil {
					RecordTrace(&ConfigstoreTraceEntry{
						OperatorId:                     getTraceServiceName(),
						Type:                           ConfigstoreTraceEntry_CLIENT_FAILED_RECONNECT,
						ErrorString: 										fmt.Sprintf("%v", watcherReconnectErr),
					})
					time.Sleep(30 * time.Second)
					continue
				} else {
					// Connection re-established, loop back around again to receive updates.
					RecordTrace(&ConfigstoreTraceEntry{
						OperatorId:                     getTraceServiceName(),
						Type:                           ConfigstoreTraceEntry_CLIENT_CONNECTION_REESTABLISHED,
					})
				}
			}
			if respErr == nil || status.Code(respErr) == codes.OK {
				if resp == nil {
					RecordTrace(&ConfigstoreTraceEntry{
						OperatorId:                     getTraceServiceName(),
						Type:                           ConfigstoreTraceEntry_CLIENT_GOT_NIL_BUG_IGNORING,
					})
					time.Sleep(1 * time.Second)
					continue
				}

				switch b := resp.Response.(type) {
				case *TypedWatchTransactionsResponse_InitialState:
					RecordTrace(&ConfigstoreTraceEntry{
						OperatorId:                     getTraceServiceName(),
						Type:                           ConfigstoreTraceEntry_INITIAL_STATE_RECEIVE_BEGIN,
					})
					// handle receiving initial state
					configstore.mutex.Lock()
					{{ range $kindName, $kind := .Kinds }}
					{
						var keys []string
						ref := configstore.{{ $kindName }}s.(*{{ $kindName }}ImplStore)
						for k := range ref.store {
							keys = append(keys, k)
						}
						for _, s := range keys {
							oldEntity, ok := ref.store[s]
							if ok {
								_ = oldEntity
								{{ template "indexstoresremoveinternal" $kindName }}
								RecordTrace(&ConfigstoreTraceEntry{
									OperatorId:                     getTraceServiceName(),
									Type:                           ConfigstoreTraceEntry_IN_MEMORY_DELETE_ENTITY,
									Key: 														oldEntity.Key,
								})
							}
							delete(ref.store, s)
						}
					}
					{{ end }}
					for _, entity := range b.InitialState.Entities {
						RecordTraceWithCustomEntity(&ConfigstoreTraceEntry{
							OperatorId:                     getTraceServiceName(),
							Type:                           ConfigstoreTraceEntry_INITIAL_STATE_RECEIVE_ENTITY,
						}, entity.Entity)

						switch e := entity.Entity.(type) {
						{{ range $kindName, $kind := .Kinds }}
						case *TypedTransactionEntity_{{ $kindName }}:
							{
								newEntity := e.{{ $kindName }}
								ref := configstore.{{ $kindName }}s.(*{{ $kindName }}ImplStore)
								s := SerializeKey(newEntity.Key)
								{{ template "indexstoresupdateinternal" $kindName }}
								ref.store[s] = newEntity
								RecordTraceWithCustomEntity(&ConfigstoreTraceEntry{
									OperatorId:     getTraceServiceName(),
									Type:           ConfigstoreTraceEntry_IN_MEMORY_STORE_ENTITY,
									Key: 						newEntity.Key,
								}, newEntity)
							}
						{{ end }}
						}
					}
					if isLocked {
						isLocked = false
						mut.Unlock()
					}
					configstore.mutex.Unlock()
					RecordTrace(&ConfigstoreTraceEntry{
						OperatorId:                     getTraceServiceName(),
						Type:                           ConfigstoreTraceEntry_INITIAL_STATE_RECEIVE_END,
					})
				case *TypedWatchTransactionsResponse_Batch:
					// handle receiving batch
					RecordTrace(&ConfigstoreTraceEntry{
						OperatorId:                     getTraceServiceName(),
						Type:                           ConfigstoreTraceEntry_TRANSACTION_BATCH_RECEIVE_BEGIN,
						TransactionId: 									b.Batch.Id,
					})
					configstore.mutex.Lock()
					for _, entity := range b.Batch.MutatedEntities {
						switch e := entity.Entity.(type) {
						{{ range $kindName, $kind := .Kinds }}
						case *TypedTransactionEntity_{{ $kindName }}:
							{
								newEntity := e.{{ $kindName }}
								ref := configstore.{{ $kindName }}s.(*{{ $kindName }}ImplStore)
								s := SerializeKey(newEntity.Key)
								oldEntity, ok := ref.store[s]
								if ok {
									_ = oldEntity
									{{ template "indexstoresremoveinternal" $kindName }}
									RecordTrace(&ConfigstoreTraceEntry{
										OperatorId:                     getTraceServiceName(),
										Type:                           ConfigstoreTraceEntry_IN_MEMORY_DELETE_ENTITY,
										TransactionId: 									b.Batch.Id,
										Key: 														oldEntity.Key,
									})
								}
								{{ template "indexstoresupdateinternal" $kindName }}
								ref.store[s] = newEntity
								RecordTraceWithCustomEntity(&ConfigstoreTraceEntry{
									OperatorId:     getTraceServiceName(),
									Type:           ConfigstoreTraceEntry_IN_MEMORY_STORE_ENTITY,
									TransactionId: 	b.Batch.Id,
									Key: 						newEntity.Key,
								}, newEntity)
							}
						{{ end }}
						}
					}
					for _, key := range b.Batch.DeletedKeys {
						s := SerializeKey(key)
						RecordTrace(&ConfigstoreTraceEntry{
							OperatorId:                     getTraceServiceName(),
							Type:                           ConfigstoreTraceEntry_IN_MEMORY_DELETE_ENTITY,
							TransactionId: 									b.Batch.Id,
							Key: 														key,
						})
						{{ range $kindName, $kind := .Kinds }}
						delete(configstore.{{ $kindName }}s.(*{{ $kindName }}ImplStore).store, s)
						{{ end }}
					}
					configstore.mutex.Unlock()
					RecordTrace(&ConfigstoreTraceEntry{
						OperatorId:                     getTraceServiceName(),
						Type:                           ConfigstoreTraceEntry_TRANSACTION_BATCH_RECEIVE_END,
						TransactionId: 									b.Batch.Id,
					})
				}
			} else {
				// We got some other kind of error e.g. configstore is unavailable, or the Watch endpoint
				// returned an error and will no longer deliver new updates. In this case, we must always
				// reconnect as we can't trust the state of the server side requests to be one in which 
				// retrying Recv() will ever work.
				RecordTrace(&ConfigstoreTraceEntry{
					OperatorId:                     getTraceServiceName(),
					Type:                           ConfigstoreTraceEntry_CLIENT_GOT_UNEXPECTED_CODE_ATTEMPTING_RECONNECT,
					ReconnectionCodeString:         status.Code(respErr).String(),
				})
				watcher.CloseSend()
				newWatcher, watcherReconnectErr := client.Watch(ctx, &TypedWatchTransactionsRequest{})
				watcher = newWatcher
				if watcherReconnectErr != nil {
					RecordTrace(&ConfigstoreTraceEntry{
						OperatorId:                     getTraceServiceName(),
						Type:                           ConfigstoreTraceEntry_CLIENT_FAILED_RECONNECT,
						ErrorString: 										fmt.Sprintf("%v", watcherReconnectErr),
					})
					time.Sleep(30 * time.Second)
					continue
				} else {
					// Connection re-established, loop back around again to receive updates.
					RecordTrace(&ConfigstoreTraceEntry{
						OperatorId:                     getTraceServiceName(),
						Type:                           ConfigstoreTraceEntry_CLIENT_CONNECTION_REESTABLISHED,
					})
				}
			}
		}
	}()

	// wait for initial state
	mut.Lock()

	return configstore, nil
}

{{ range $kindName, $kind := .Kinds }}
type {{ $kindName }}ImplStore struct {
	configstore *Configstore
	client {{ $kindName }}ServiceClient
	store map[string]*{{ $kindName }}
	{{ range $i, $index := $kind.Indexes }}
		{{ if isinmemoryindex $index }}
			{{ if isfieldindex $index }}
				{{ $field := getfieldforindex $kindName $index }}
				{{ if $field }}
	indexstore_{{ $index.Name }} map[{{ template "fieldindexkeytype" $field }}]*{{ $kindName }}
				{{ end }}
			{{ else if iscomputedindex $index }}
				{{ if iscomputedfnv64aindex $index }}
	indexstore_{{ $index.Name }} map[uint64]*{{ $kindName }}
				{{ else if iscomputedfnv64apairindex $index }}
	indexstore_{{ $index.Name }} map[uint64]*{{ $kindName }}
				{{ end }}
			{{ end }}
		{{ end }}
	{{ end }}
}

type {{ $kindName }}Store interface {
	Client() {{ $kindName }}ServiceClient
	Create(ctx context.Context, entity *{{ $kindName }}) (*{{ $kindName }}, error)
	Update(ctx context.Context, entity *{{ $kindName }}) (*{{ $kindName }}, error)
	Upsert(ctx context.Context, entity *{{ $kindName }}) (*{{ $kindName }}, error)
	Delete(ctx context.Context, key *Key) (*{{ $kindName }}, error)
	GetAndCheck(key *Key) (*{{ $kindName }}, bool)
	Get(key *Key) *{{ $kindName }}
	GetKeys() []*Key
	{{- range $i, $index := $kind.Indexes -}}
		{{- if isinmemoryindex $index -}}
			{{- if isfieldindex $index -}}
				{{- $field := getfieldforindex $kindName $index -}}
				{{- if $field }}
	GetBy{{ $index.Name }}(key {{ template "fieldindexorigtype" $field }}) *{{ $kindName }}
	GetAndCheckBy{{ $index.Name }}(key {{ template "fieldindexorigtype" $field }}) (*{{ $kindName }}, bool)
				{{ end -}}
			{{- else if iscomputedindex $index -}}
				{{- if iscomputedfnv64aindex $index }}
	GetBy{{ $index.Name }}(key uint64) *{{ $kindName }}
	GetAndCheckBy{{ $index.Name }}(key uint64) (*{{ $kindName }}, bool)
				{{ else if iscomputedfnv64apairindex $index }}
	GetBy{{ $index.Name }}(key uint64) *{{ $kindName }}
	GetAndCheckBy{{ $index.Name }}(key uint64) (*{{ $kindName }}, bool)
				{{- end -}}
			{{- end -}}
		{{- end -}}
	{{- end }}
}

func (c *{{ $kindName }}ImplStore) Client() {{ $kindName }}ServiceClient {
	return c.client
}

{{ range $i, $index := $kind.Indexes }}
	{{- if isinmemoryindex $index -}}
		{{- if isfieldindex $index -}}
			{{- $field := getfieldforindex $kindName $index -}}
			{{- if $field }}
func (c *{{ $kindName }}ImplStore) GetBy{{ $index.Name }}(key {{ template "fieldindexorigtype" $field }}) *{{ $kindName }} {
	c.configstore.mutex.RLock()
	defer c.configstore.mutex.RUnlock()
	return c.indexstore_{{ $index.Name }}[{{ template "fieldindexserializetotype" $field }}]
}

func (c *{{ $kindName }}ImplStore) GetAndCheckBy{{ $index.Name }}(key {{ template "fieldindexorigtype" $field }}) (*{{ $kindName }}, bool) {
	c.configstore.mutex.RLock()
	defer c.configstore.mutex.RUnlock()
	val, ok := c.indexstore_{{ $index.Name }}[{{ template "fieldindexserializetotype" $field }}]
	return val, ok
}

func (c *{{ $kindName }}Snapshot) GetBy{{ $index.Name }}(key {{ template "fieldindexorigtype" $field }}) *{{ $kindName }} {
	return c.{{ $kindName }}s_By{{ $index.Name }}[{{ template "fieldindexserializetotype" $field }}]
}

func (c *{{ $kindName }}Snapshot) GetAndCheckBy{{ $index.Name }}(key {{ template "fieldindexorigtype" $field }}) (*{{ $kindName }}, bool) {
	val, ok := c.{{ $kindName }}s_By{{ $index.Name }}[{{ template "fieldindexserializetotype" $field }}]
	return val, ok
}
			{{- end -}}
		{{- else if iscomputedindex $index -}}
			{{- if iscomputedfnv64aindex $index }}
func (c *{{ $kindName }}ImplStore) GetBy{{ $index.Name }}(key uint64) *{{ $kindName }} {
	c.configstore.mutex.RLock()
	defer c.configstore.mutex.RUnlock()
	return c.indexstore_{{ $index.Name }}[key]
}

func (c *{{ $kindName }}ImplStore) GetAndCheckBy{{ $index.Name }}(key uint64) (*{{ $kindName }}, bool) {
	c.configstore.mutex.RLock()
	defer c.configstore.mutex.RUnlock()
	val, ok := c.indexstore_{{ $index.Name }}[key]
	return val, ok
}

func (c *{{ $kindName }}Snapshot) GetBy{{ $index.Name }}(key uint64) *{{ $kindName }} {
	return c.{{ $kindName }}s_By{{ $index.Name }}[key]
}

func (c *{{ $kindName }}Snapshot) GetAndCheckBy{{ $index.Name }}(key uint64) (*{{ $kindName }}, bool) {
	val, ok := c.{{ $kindName }}s_By{{ $index.Name }}[key]
	return val, ok
}
			{{ else if iscomputedfnv64apairindex $index }}
func (c *{{ $kindName }}ImplStore) GetBy{{ $index.Name }}(key uint64) *{{ $kindName }} {
	c.configstore.mutex.RLock()
	defer c.configstore.mutex.RUnlock()
	return c.indexstore_{{ $index.Name }}[key]
}

func (c *{{ $kindName }}ImplStore) GetAndCheckBy{{ $index.Name }}(key uint64) (*{{ $kindName }}, bool) {
	c.configstore.mutex.RLock()
	defer c.configstore.mutex.RUnlock()
	val, ok := c.indexstore_{{ $index.Name }}[key]
	return val, ok
}

func (c *{{ $kindName }}Snapshot) GetBy{{ $index.Name }}(key uint64) *{{ $kindName }} {
	return c.{{ $kindName }}s_By{{ $index.Name }}[key]
}

func (c *{{ $kindName }}Snapshot) GetAndCheckBy{{ $index.Name }}(key uint64) (*{{ $kindName }}, bool) {
	val, ok := c.{{ $kindName }}s_By{{ $index.Name }}[key]
	return val, ok
}
			{{- end -}}
		{{- end -}}
	{{- end -}}
{{- end }}

func (c *{{ $kindName }}ImplStore) GetKeys() []*Key {
	keys := make([]*Key, len(c.store))
	i := 0
	for _, entity := range c.store {
		keys[i] = entity.Key
		i += 1
	}
	return keys
}

func (c *{{ $kindName }}ImplStore) Get(key *Key) *{{ $kindName }} {
	c.configstore.mutex.RLock()
	defer c.configstore.mutex.RUnlock()
	return c.store[SerializeKey(key)]
}

func (c *{{ $kindName }}ImplStore) GetAndCheck(key *Key) (*{{ $kindName }}, bool) {
	c.configstore.mutex.RLock()
	defer c.configstore.mutex.RUnlock()
	val, ok := c.store[SerializeKey(key)]
	return val, ok
}

func (c *{{ $kindName }}Snapshot) GetKeys() []*Key {
	keys := make([]*Key, len(c.{{ $kindName }}s))
	i := 0
	for _, entity := range c.{{ $kindName }}s {
		keys[i] = entity.Key
		i += 1
	}
	return keys
}

func (c *{{ $kindName }}Snapshot) Get(key *Key) *{{ $kindName }} {
	return c.{{ $kindName }}s[SerializeKey(key)]
}

func (c *{{ $kindName }}Snapshot) GetAndCheck(key *Key) (*{{ $kindName }}, bool) {
	val, ok := c.{{ $kindName }}s[SerializeKey(key)]
	return val, ok
}

func (ref *{{ $kindName }}ImplStore) Create(ctx context.Context, entity *{{ $kindName }}) (*{{ $kindName }}, error) {
	resp, err := ref.client.Create(ctx, &Create{{ $kindName }}Request{
		Entity: entity,
	})
	if err != nil {
		return nil, err
	}
	s := SerializeKey(resp.Entity.Key)
	ref.configstore.mutex.Lock()
	{{ template "indexstoresupdate" $kindName }}
	ref.store[s] = resp.Entity
	ref.configstore.mutex.Unlock()
	return resp.Entity, nil
}

func (ref *{{ $kindName }}ImplStore) Update(ctx context.Context, entity *{{ $kindName }}) (*{{ $kindName }}, error) {
	resp, err := ref.client.Update(ctx, &Update{{ $kindName }}Request{
		Entity: entity,
	})
	if err != nil {
		return nil, err
	}
	s := SerializeKey(resp.Entity.Key)
	ref.configstore.mutex.Lock()
	{{ template "indexstoresremove" $kindName }}
	{{ template "indexstoresupdate" $kindName }}
	ref.store[s] = resp.Entity
	ref.configstore.mutex.Unlock()
	return resp.Entity, nil
}

func (ref *{{ $kindName }}ImplStore) Upsert(ctx context.Context, entity *{{ $kindName }}) (*{{ $kindName }}, error) {
	_, ok := ref.GetAndCheck(entity.Key)
	if !ok {
		// try create
		entity, err := ref.Create(ctx, entity)
		if err != nil {
			if strings.Contains(err.Error(), "already exists") {
				// fallback to update
			} else {
				return nil, err
			}
		} else {
			return entity, nil
		}
	}
	entity, err := ref.Update(ctx, entity)
	return entity, err
}

func (ref *{{ $kindName }}ImplStore) Delete(ctx context.Context, key *Key) (*{{ $kindName }}, error) {
	resp, err := ref.client.Delete(ctx, &Delete{{ $kindName }}Request{
		Key: key,
	})
	if err != nil {
		return nil, err
	}
	s := SerializeKey(resp.Entity.Key)
	ref.configstore.mutex.Lock()
	{{ template "indexstoresremove" $kindName }}
	delete(ref.store, s)
	ref.configstore.mutex.Unlock()
	return resp.Entity, nil
}
{{ end }}