func Fnv64a(val string) uint64 {
	hash := fnv.New64a()
	hash.Write(([]byte)(val))
	return hash.Sum64()
}

func Fnv64aPair(a uint64, b uint64) uint64 {
	hash := fnv.New64a()
	if a > b {
		tmp := a
		a = b
		b = tmp
	}
	key := make([]byte, 16)
	binary.LittleEndian.PutUint64(key, a)
	binary.LittleEndian.PutUint64(key[8:], b)
	hash.Write(key)
	return hash.Sum64()
}

func CreateTopLevelKey(partitionId *PartitionId, pathElement *PathElement) *Key {
	return &Key{
		PartitionId: partitionId,
		Path: []*PathElement{pathElement},
	}
}

func CreateIncompleteTopLevelKey(partitionId *PartitionId, kind string) *Key {
	return &Key{
		PartitionId: partitionId,
		Path: []*PathElement{
			&PathElement{
				Kind: kind,
			},
		},
	}
}

func CreateDescendantKey(parent *Key, pathElement *PathElement) *Key {
	newKey := &Key{
		PartitionId: &PartitionId{
			Namespace: parent.PartitionId.Namespace,
		},
		Path: nil,
	}
	for _, elem := range parent.Path {
		switch elem.IdType.(type) {
		case *PathElement_Id:
			newKey.Path = append(newKey.Path, &PathElement{
				Kind: elem.Kind,
				IdType: &PathElement_Id{
					Id: elem.GetId(),
				},
			})
			break
		case *PathElement_Name:
			newKey.Path = append(newKey.Path, &PathElement{
				Kind: elem.Kind,
				IdType: &PathElement_Name{
					Name: elem.GetName(),
				},
			})
			break
		}
	}
	switch pathElement.IdType.(type) {
	case *PathElement_Id:
		newKey.Path = append(newKey.Path, &PathElement{
			Kind: pathElement.Kind,
			IdType: &PathElement_Id{
				Id: pathElement.GetId(),
			},
		})
		break
	case *PathElement_Name:
		newKey.Path = append(newKey.Path, &PathElement{
			Kind: pathElement.Kind,
			IdType: &PathElement_Name{
				Name: pathElement.GetName(),
			},
		})
		break
	}
	return newKey
}

func SerializeTimestamp(ts *timestamp.Timestamp) string {
	if ts == nil {
		return ""
	}

	return ts.String()
}

func SerializeKey(key *Key) string {
	if key == nil {
		return ""
	}

	var elements []string
	for _, pathElement := range key.Path {
		if _, ok := pathElement.IdType.(*PathElement_Id); ok {
			elements = append(elements, fmt.Sprintf("%s:id=%d", pathElement.GetKind(), pathElement.GetId()))
		} else if _, ok := pathElement.IdType.(*PathElement_Name); ok {
			elements = append(elements, fmt.Sprintf("%s:name=%s", pathElement.GetKind(), pathElement.GetName()))
		} else {
			elements = append(elements, fmt.Sprintf("%s:unset", pathElement.GetKind()))
		}
	}
	return fmt.Sprintf("ns=%s|%s", key.PartitionId.Namespace, strings.Join(elements, "|"))
}

func CompareKeys(a *Key, b *Key) bool {
	return SerializeKey(a) == SerializeKey(b)
}

{{ range $kindName, $kind := .Kinds }}
func CreateTopLevel_{{ $kindName }}_NameKey(partitionId *PartitionId, name string) *Key {
	return &Key{
		PartitionId: partitionId,
		Path: []*PathElement{
			&PathElement{
				Kind: "{{ $kindName }}",
				IdType: &PathElement_Name{
					Name: name,
				},
			},
		},
	}
}

func CreateTopLevel_{{ $kindName }}_IdKey(partitionId *PartitionId, id int64) *Key {
	return &Key{
		PartitionId: partitionId,
		Path: []*PathElement{
			&PathElement{
				Kind: "{{ $kindName }}",
				IdType: &PathElement_Id{
				  Id: id,
				},
			},
		},
	}
}

func CreateTopLevel_{{ $kindName }}_IncompleteKey(partitionId *PartitionId) *Key {
	return &Key{
		PartitionId: partitionId,
		Path: []*PathElement{
			&PathElement{
				Kind: "{{ $kindName }}",
				IdType: nil,
			},
		},
	}
}
{{ end }}

{{- define "fieldindexkeytype" -}}
{{- if eq .Type 1 -}}
float64
{{- else if eq .Type 2 -}}
int64
{{- else if eq .Type 8 -}}
uint64
{{- else if eq .Type 4 -}}
string
{{- else if eq .Type 6 -}}
string
{{- else if eq .Type 7 -}}
string
{{- else if eq .Type 5 -}}
bool
{{- else if eq .Type 3 -}}
string
{{- end -}}
{{- end -}}

{{- define "fieldindexorigtype" -}}
{{- if eq .Type 1 -}}
float64
{{- else if eq .Type 2 -}}
int64
{{- else if eq .Type 8 -}}
uint64
{{- else if eq .Type 4 -}}
*timestamp.Timestamp
{{- else if eq .Type 6 -}}
[]byte
{{- else if eq .Type 7 -}}
*Key
{{- else if eq .Type 5 -}}
bool
{{- else if eq .Type 3 -}}
string
{{- end -}}
{{- end -}}

{{- define "fieldindexserializetotype" -}}
{{- if eq .Type 4 -}}
SerializeTimestamp(key)
{{- else if eq .Type 6 -}}
string(key)
{{- else if eq .Type 7 -}}
SerializeKey(key)
{{- else -}}
key
{{- end -}}
{{- end -}}

{{ define "indexstoresupdate" }}
	newEntity := resp.Entity
	_ = newEntity
	{{ template "indexstoresupdateinternal" . }}
{{ end }}

{{ define "indexstoresupdateinternal" }}
	{{ $kind := getschemakind . -}}
	{{- $kindName := . }}
	{{- range $i, $index := $kind.Indexes -}}
		{{- if isinmemoryindex $index -}}
			{{- if isfieldindex $index -}}
				{{- $field := getfieldforindex $kindName $index -}}
				{{- if $field -}}
{
	key := newEntity.{{- camelcase $field.Name }}
	idx := {{- template "fieldindexserializetotype" $field }}
	ref.indexstore_{{- $index.Name -}}[idx] = newEntity
}
				{{ end -}}
			{{- else if iscomputedindex $index -}}
				{{- if iscomputedfnv64aindex $index -}}
					{{- $field := getcomputedfnv64afieldforindex $kindName $index -}}
					{{- if $field }}
{
	key := newEntity.{{- camelcase $field.Name }}
	idx := Fnv64a(key)
	ref.indexstore_{{- $index.Name -}}[idx] = newEntity
}
					{{ end -}}
				{{- else if iscomputedfnv64apairindex $index -}}
					{{- $field1 := getcomputedfnv64apairfield1forindex $kindName $index -}}
					{{- $field2 := getcomputedfnv64apairfield2forindex $kindName $index -}}
					{{- if and $field1 $field2 }}
{
	field1 := newEntity.{{- camelcase $field.Name }}
	field2 := newEntity.{{- camelcase $field.Name }}
	idx := Fnv64aPair(field1, field2)
	ref.indexstore_{{- $index.Name -}}[idx] = newEntity
}
					{{ end -}}
				{{- end -}}
			{{- end -}}
		{{- end -}}
	{{- end -}}
{{ end }}

{{ define "indexstoresremove" }}
	oldEntity, ok := ref.store[s]
	if ok {
		_ = oldEntity
		{{ template "indexstoresremoveinternal" . }}
	}
{{ end }}

{{ define "indexstoresremoveinternal" }}
	{{ $kind := getschemakind . -}}
	{{- $kindName := . }}
	{{- range $i, $index := $kind.Indexes -}}
		{{- if isinmemoryindex $index -}}
			{{- if isfieldindex $index -}}
				{{- $field := getfieldforindex $kindName $index -}}
				{{- if $field -}}
{
	key := oldEntity.{{- camelcase $field.Name }}
	idx := {{- template "fieldindexserializetotype" $field }}
	delete(ref.indexstore_{{- $index.Name -}}, idx)
}
				{{ end -}}
			{{- else if iscomputedindex $index -}}
				{{- if iscomputedfnv64aindex $index -}}
					{{- $field := getcomputedfnv64afieldforindex $kindName $index -}}
					{{- if $field }}
{
	key := oldEntity.{{- camelcase $field.Name }}
	idx := Fnv64a(key)
	delete(ref.indexstore_{{- $index.Name -}}, idx)
}
					{{ end -}}
				{{- else if iscomputedfnv64apairindex $index -}}
					{{- $field1 := getcomputedfnv64apairfield1forindex $kindName $index -}}
					{{- $field2 := getcomputedfnv64apairfield2forindex $kindName $index -}}
					{{- if and $field1 $field2 }}
{
	field1 := oldEntity.{{- camelcase $field.Name }}
	field2 := oldEntity.{{- camelcase $field.Name }}
	idx := Fnv64aPair(field1, field2)
	delete(ref.indexstore_{{- $index.Name -}}, idx)
}
					{{ end -}}
				{{- end -}}
			{{- end -}}
		{{- end -}}
	{{- end }}
{{ end }}

type Configstore struct {
	conn *grpc.ClientConn
	mutex sync.RWMutex

	{{ range $kindName, $kind := .Kinds }}
	{{ $kindName }}s {{ $kindName }}Store
	{{ end }}
}

func ConnectToConfigstore(conn *grpc.ClientConn) (*Configstore, error) {
	configstore := &Configstore{
		conn: conn,
	}
	{{ range $kindName, $kind := .Kinds }}
	configstore.{{ $kindName }}s = &{{ $kindName }}ImplStore{
		configstore: configstore,
		client:   New{{ $kindName }}ServiceClient(configstore.conn),
		store:    make(map[string]*{{ $kindName }}),
		{{ range $i, $index := $kind.Indexes }}
			{{ if isinmemoryindex $index }}
				{{ if isfieldindex $index }}
					{{ $field := getfieldforindex $kindName $index }}
					{{ if $field }}
		indexstore_{{ $index.Name }}: make(map[{{ template "fieldindexkeytype" $field }}]*{{ $kindName }}),
					{{ end }}
				{{ else if iscomputedindex $index }}
					{{ if iscomputedfnv64aindex $index }}
		indexstore_{{ $index.Name }}: make(map[uint64]*{{ $kindName }}),
					{{ else if iscomputedfnv64apairindex $index }}
		indexstore_{{ $index.Name }}: make(map[uint64]*{{ $kindName }}),
					{{ end }}
				{{ end }}
			{{ end }}
		{{ end }}
	}
	{{ end }}
	client := NewTransactionServiceClient(configstore.conn)
	var mut sync.Mutex
	mut.Lock()
	watcher, err := client.Watch(ctx, &TypedWatchTransactionsRequest{})
	if err != nil {
		return nil, err
	}
	go func() {
		for {
			resp, err := watcher.Recv()
			if err == io.EOF {
				// Retry the Watch request itself
				watcher.CloseSend()
				watcher, err = client.Watch(ctx, &TypedWatchTransactionsRequest{})
				if err != nil {
					time.Sleep(30 * time.Second)
					continue
				} else {
					// Connection re-established, loop back around again to receive updates.
				}
			}
			if err == nil || status.Code(err) == codes.OK {
				if resp == nil {
					time.Sleep(1 * time.Second)
					continue
				}

				switch b := resp.Response.(type) {
				case *TypedWatchTransactionsResponse_InitialState:
					// handle receiving initial state
					configstore.mutex.Lock()
					for _, entity := range b.InitialState.Entities {
						switch e := entity.Entity.(type) {
						{{ range $kindName, $kind := .Kinds }}
						case *TypedTransactionEntity_{{ $kindName }}:
							{
								newEntity := e.{{ $kindName }}
								ref := configstore.{{ $kindName }}s.(*{{ $kindName }}ImplStore)
								s := SerializeKey(newEntity.Key)
								{{ template "indexstoresupdateinternal" $kindName }}
								ref.store[s] = newEntity
							}
						{{ end }}
						}
					}
					configstore.mutex.Unlock()
					mut.Unlock()
				case *TypedWatchTransactionsResponse_Batch:
					// handle receiving batch
					configstore.mutex.Lock()
					for _, entity := range b.Batch.MutatedEntities {
						switch e := entity.Entity.(type) {
						{{ range $kindName, $kind := .Kinds }}
						case *TypedTransactionEntity_{{ $kindName }}:
							{
								newEntity := e.{{ $kindName }}
								ref := configstore.{{ $kindName }}s.(*{{ $kindName }}ImplStore)
								s := SerializeKey(newEntity.Key)
								oldEntity, ok := ref.store[s]
								if ok {
									_ = oldEntity
									{{ template "indexstoresremoveinternal" $kindName }}
								}
								{{ template "indexstoresupdateinternal" $kindName }}
								ref.store[s] = newEntity
							}
						{{ end }}
						}
					}
					for _, key := range b.Batch.DeletedKeys {
						s := SerializeKey(key)
						{{ range $kindName, $kind := .Kinds }}
						delete(configstore.{{ $kindName }}s.(*{{ $kindName }}ImplStore).store, s)
						{{ end }}
					}
					configstore.mutex.Unlock()
				}

			} else if status.Code(err) == codes.Unavailable {
				// Retry the Watch request itself
				watcher.CloseSend()
				watcher, err = client.Watch(ctx, &TypedWatchTransactionsRequest{})
				if err != nil {
					time.Sleep(30 * time.Second)
					continue
				} else {
					// Connection re-established, loop back around again to receive updates.
				}
			} else {
				time.Sleep(1 * time.Second)
				continue
			}
		}
	}()

	// wait for initial state
	mut.Lock()

	return configstore, nil
}

{{ range $kindName, $kind := .Kinds }}
type {{ $kindName }}ImplStore struct {
	configstore *Configstore
	client {{ $kindName }}ServiceClient
	store map[string]*{{ $kindName }}
	{{ range $i, $index := $kind.Indexes }}
		{{ if isinmemoryindex $index }}
			{{ if isfieldindex $index }}
				{{ $field := getfieldforindex $kindName $index }}
				{{ if $field }}
	indexstore_{{ $index.Name }} map[{{ template "fieldindexkeytype" $field }}]*{{ $kindName }}
				{{ end }}
			{{ else if iscomputedindex $index }}
				{{ if iscomputedfnv64aindex $index }}
	indexstore_{{ $index.Name }} map[uint64]*{{ $kindName }}
				{{ else if iscomputedfnv64apairindex $index }}
	indexstore_{{ $index.Name }} map[uint64]*{{ $kindName }}
				{{ end }}
			{{ end }}
		{{ end }}
	{{ end }}
}

type {{ $kindName }}Store interface {
	Client() {{ $kindName }}ServiceClient
	Create(ctx context.Context, entity *{{ $kindName }}) (*{{ $kindName }}, error)
	Update(ctx context.Context, entity *{{ $kindName }}) (*{{ $kindName }}, error)
	Delete(ctx context.Context, key *Key) (*{{ $kindName }}, error)
	GetAndCheck(key *Key) (*{{ $kindName }}, bool)
	Get(key *Key) *{{ $kindName }}
	GetKeys() []*Key
	{{- range $i, $index := $kind.Indexes -}}
		{{- if isinmemoryindex $index -}}
			{{- if isfieldindex $index -}}
				{{- $field := getfieldforindex $kindName $index -}}
				{{- if $field }}
	GetBy{{ $index.Name }}(key {{ template "fieldindexorigtype" $field }}) *{{ $kindName }}
	GetAndCheckBy{{ $index.Name }}(key {{ template "fieldindexorigtype" $field }}) (*{{ $kindName }}, bool)
				{{ end -}}
			{{- else if iscomputedindex $index -}}
				{{- if iscomputedfnv64aindex $index }}
	GetBy{{ $index.Name }}(key uint64) *{{ $kindName }}
	GetAndCheckBy{{ $index.Name }}(key uint64) (*{{ $kindName }}, bool)
				{{ else if iscomputedfnv64apairindex $index }}
	GetBy{{ $index.Name }}(key uint64) *{{ $kindName }}
	GetAndCheckBy{{ $index.Name }}(key uint64) (*{{ $kindName }}, bool)
				{{- end -}}
			{{- end -}}
		{{- end -}}
	{{- end }}
}

func (c *{{ $kindName }}ImplStore) Client() {{ $kindName }}ServiceClient {
	return c.client
}

{{ range $i, $index := $kind.Indexes }}
	{{- if isinmemoryindex $index -}}
		{{- if isfieldindex $index -}}
			{{- $field := getfieldforindex $kindName $index -}}
			{{- if $field }}
func (c *{{ $kindName }}ImplStore) GetBy{{ $index.Name }}(key {{ template "fieldindexorigtype" $field }}) *{{ $kindName }} {
	c.configstore.mutex.RLock()
	defer c.configstore.mutex.RUnlock()
	return c.indexstore_{{ $index.Name }}[{{ template "fieldindexserializetotype" $field }}]
}

func (c *{{ $kindName }}ImplStore) GetAndCheckBy{{ $index.Name }}(key {{ template "fieldindexorigtype" $field }}) (*{{ $kindName }}, bool) {
	c.configstore.mutex.RLock()
	defer c.configstore.mutex.RUnlock()
	val, ok := c.indexstore_{{ $index.Name }}[{{ template "fieldindexserializetotype" $field }}]
	return val, ok
}
			{{- end -}}
		{{- else if iscomputedindex $index -}}
			{{- if iscomputedfnv64aindex $index }}
func (c *{{ $kindName }}ImplStore) GetBy{{ $index.Name }}(key uint64) *{{ $kindName }} {
	c.configstore.mutex.RLock()
	defer c.configstore.mutex.RUnlock()
	return c.indexstore_{{ $index.Name }}[key]
}

func (c *{{ $kindName }}ImplStore) GetAndCheckBy{{ $index.Name }}(key uint64) (*{{ $kindName }}, bool) {
	c.configstore.mutex.RLock()
	defer c.configstore.mutex.RUnlock()
	val, ok := c.indexstore_{{ $index.Name }}[key]
	return val, ok
}
			{{ else if iscomputedfnv64apairindex $index }}
func (c *{{ $kindName }}ImplStore) GetBy{{ $index.Name }}(key uint64) *{{ $kindName }} {
	c.configstore.mutex.RLock()
	defer c.configstore.mutex.RUnlock()
	return c.indexstore_{{ $index.Name }}[key]
}

func (c *{{ $kindName }}ImplStore) GetAndCheckBy{{ $index.Name }}(key uint64) (*{{ $kindName }}, bool) {
	c.configstore.mutex.RLock()
	defer c.configstore.mutex.RUnlock()
	val, ok := c.indexstore_{{ $index.Name }}[key]
	return val, ok
}
			{{- end -}}
		{{- end -}}
	{{- end -}}
{{- end -}}

func (c *{{ $kindName }}ImplStore) GetKeys() []*Key {
	keys := make([]*Key, len(c.store))
	i := 0
	for _, entity := range c.store {
		keys[i] = entity.Key
		i += 1
	}
	return keys
}

func (c *{{ $kindName }}ImplStore) Get(key *Key) *{{ $kindName }} {
	c.configstore.mutex.RLock()
	defer c.configstore.mutex.RUnlock()
	return c.store[SerializeKey(key)]
}

func (c *{{ $kindName }}ImplStore) GetAndCheck(key *Key) (*{{ $kindName }}, bool) {
	c.configstore.mutex.RLock()
	defer c.configstore.mutex.RUnlock()
	val, ok := c.store[SerializeKey(key)]
	return val, ok
}

func (ref *{{ $kindName }}ImplStore) Create(ctx context.Context, entity *{{ $kindName }}) (*{{ $kindName }}, error) {
	resp, err := ref.client.Create(ctx, &Create{{ $kindName }}Request{
		Entity: entity,
	})
	if err != nil {
		return nil, err
	}
	s := SerializeKey(resp.Entity.Key)
	ref.configstore.mutex.Lock()
	{{ template "indexstoresupdate" $kindName }}
	ref.store[s] = resp.Entity
	ref.configstore.mutex.Unlock()
	return resp.Entity, nil
}

func (ref *{{ $kindName }}ImplStore) Update(ctx context.Context, entity *{{ $kindName }}) (*{{ $kindName }}, error) {
	resp, err := ref.client.Update(ctx, &Update{{ $kindName }}Request{
		Entity: entity,
	})
	if err != nil {
		return nil, err
	}
	s := SerializeKey(resp.Entity.Key)
	ref.configstore.mutex.Lock()
	{{ template "indexstoresremove" $kindName }}
	{{ template "indexstoresupdate" $kindName }}
	ref.store[s] = resp.Entity
	ref.configstore.mutex.Unlock()
	return resp.Entity, nil
}

func (ref *{{ $kindName }}ImplStore) Delete(ctx context.Context, key *Key) (*{{ $kindName }}, error) {
	resp, err := ref.client.Delete(ctx, &Delete{{ $kindName }}Request{
		Key: key,
	})
	if err != nil {
		return nil, err
	}
	s := SerializeKey(resp.Entity.Key)
	ref.configstore.mutex.Lock()
	{{ template "indexstoresremove" $kindName }}
	delete(ref.store, s)
	ref.configstore.mutex.Unlock()
	return resp.Entity, nil
}
{{ end }}